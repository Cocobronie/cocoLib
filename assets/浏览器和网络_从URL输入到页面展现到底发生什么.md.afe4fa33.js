import{_ as a,o as s,c as l,O as o}from"./chunks/framework.23072b34.js";const t="/cocoLib/images/1672fdd0e8a76be8tplv-t2oaga2asx-zoom-in-crop-mark4536000.png",n="/cocoLib/images/1672fdd0e7cb07cctplv-t2oaga2asx-zoom-in-crop-mark4536000.png",e="/cocoLib/images/1672fdd11994e3dbtplv-t2oaga2asx-zoom-in-crop-mark4536000.png",r="/cocoLib/images/image-20230612175512311.png",i="/cocoLib/images/1672fdd11d30c5d6tplv-t2oaga2asx-zoom-in-crop-mark4536000.png",P=JSON.parse('{"title":"从URL输入到页面展现到底发生什么？","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器和网络/从URL输入到页面展现到底发生什么.md","filePath":"浏览器和网络/从URL输入到页面展现到底发生什么.md","lastUpdated":null}'),p={name:"浏览器和网络/从URL输入到页面展现到底发生什么.md"},c=o('<h1 id="从url输入到页面展现到底发生什么" tabindex="-1">从URL输入到页面展现到底发生什么？ <a class="header-anchor" href="#从url输入到页面展现到底发生什么" aria-label="Permalink to &quot;从URL输入到页面展现到底发生什么？&quot;">​</a></h1><p><a href="https://juejin.cn/post/6844903717259444232" target="_blank" rel="noreferrer">从URL输入到页面展现到底发生什么？ - 掘金 (juejin.cn)</a></p><ol><li>从URL输入到页面展现到底发生什么？</li><li>URL 到底是啥？</li><li><code>http://www.w3school.com.cn/html/index.asp</code> 各部分解释一下？</li><li>浏览器如何通过域名去查询 URL 对应的 IP 呢？</li><li>TCP 三次握手作用？</li><li>TCP 三次握手过程？</li><li>HTTP 请求报文包含哪几个部分？</li><li>HTTP 响应报文包含哪几个部分？</li><li>什么时候断开连接？</li><li>TCP 四次握手作用？</li><li>TCP 四次握手过程？</li></ol><div class="tip custom-block"><p class="custom-block-title">从URL输入到页面展现到底发生什么？</p><ul><li>DNS 解析：获取服务器IP地址</li><li>TCP 连接：TCP 三次握手建立连接</li><li>浏览器：发送 HTTP 请求报文</li><li>服务器：处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ul></div><h2 id="_1、url-到底是啥" tabindex="-1">1、URL 到底是啥 <a class="header-anchor" href="#_1、url-到底是啥" aria-label="Permalink to &quot;1、URL 到底是啥&quot;">​</a></h2><p><strong>URL（Uniform Resource Locator）</strong>，统一资源定位符，用于定位互联网上资源，俗称网址。 比如 <code>http://www.w3school.com.cn/html/index.asp</code>，遵守以下的语法规则：</p><p><strong>scheme://host.domain:port/path/filename</strong> 各部分解释如下：</p><ul><li><p><strong>scheme</strong> - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</p></li><li><p><strong>host</strong> - 定义域主机（http 的默认主机是 www）</p></li><li><p><strong>domain</strong> - 定义因特网<strong>域名</strong>，比如 <code>w3school.com.cn</code></p></li><li><p><strong>port</strong> - 定义主机上的端口号（http 的默认端口号是 80）</p></li><li><p><strong>path</strong> - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</p></li><li><p><strong>filename</strong> - 定义文档/资源的名称</p></li></ul><h2 id="_2、域名解析-dns" tabindex="-1">2、域名解析（DNS） <a class="header-anchor" href="#_2、域名解析-dns" aria-label="Permalink to &quot;2、域名解析（DNS）&quot;">​</a></h2><p><strong>浏览器如何通过域名去查询 URL 对应的 IP 呢？</strong></p><ul><li><strong>浏览器缓存</strong>：浏览器会按照一定的频率缓存 DNS 记录。</li><li><strong>操作系统缓存</strong>：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li><li><strong>路由缓存</strong>：路由器也有 DNS 缓存。</li><li><strong>ISP 的 DNS 服务器</strong>：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li><strong>根服务器</strong>：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器<code>.com </code>域名服务器的 IP 地址，然后再问<code>.baidu </code>域名服务器，依次类推）</li></ul><h2 id="_3、tcp-三次握手" tabindex="-1">3、TCP 三次握手 <a class="header-anchor" href="#_3、tcp-三次握手" aria-label="Permalink to &quot;3、TCP 三次握手&quot;">​</a></h2><p><strong>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息</strong>。</p><img src="'+t+'" alt="img" style="zoom:50%;"><h4 id="_3-1-tcp-三次握手的过程如下" tabindex="-1">3.1 TCP 三次握手的过程如下： <a class="header-anchor" href="#_3-1-tcp-三次握手的过程如下" aria-label="Permalink to &quot;3.1 TCP 三次握手的过程如下：&quot;">​</a></h4><ul><li><strong>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li><li><strong>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li><li><strong>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ul><h4 id="_3-2-为啥需要三次握手" tabindex="-1">3.2 为啥需要三次握手 <a class="header-anchor" href="#_3-2-为啥需要三次握手" aria-label="Permalink to &quot;3.2 为啥需要三次握手&quot;">​</a></h4><p>谢希仁著《计算机网络》中讲“三次握手”的目的是“<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>”。</p><h2 id="_4、发送-http-请求" tabindex="-1">4、发送 HTTP 请求 <a class="header-anchor" href="#_4、发送-http-请求" aria-label="Permalink to &quot;4、发送 HTTP 请求&quot;">​</a></h2><p><strong>TCP 三次握手结束后，开始发送 HTTP 请求报文</strong>。 请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示：</p><p><img src="'+n+`" alt="img"></p><h3 id="_4-1-请求行" tabindex="-1">4.1 请求行 <a class="header-anchor" href="#_4-1-请求行" aria-label="Permalink to &quot;4.1 请求行&quot;">​</a></h3><div class="language-php"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">POST  </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">chapter17</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">user</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">html HTTP</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">1</span></span></code></pre></div><p>请求行包含：</p><ul><li><strong>请求方法</strong>：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li><li><strong>URL</strong> 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li><li><strong>协议版本</strong>即 http 版本号</li></ul><h3 id="_4-2-请求头" tabindex="-1">4.2 请求头 <a class="header-anchor" href="#_4-2-请求头" aria-label="Permalink to &quot;4.2 请求头&quot;">​</a></h3><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">Accept:</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">*</span><span style="color:#C3E88D;">/</span><span style="color:#A6ACCD;">*</span></span>
<span class="line"><span style="color:#FFCB6B;">Accept-Encoding:gzip,</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">deflate,</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">br</span></span>
<span class="line"><span style="color:#FFCB6B;">Accept-Language:zh-CN,zh</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">q</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">0.9</span><span style="color:#C3E88D;">,en</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">q</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">0.8</span><span style="color:#C3E88D;">,en-GB</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">q</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">0.7</span><span style="color:#C3E88D;">,en-US</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">q</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">0.6</span></span>
<span class="line"><span style="color:#FFCB6B;">Cache-Control:no-cache</span></span>
<span class="line"><span style="color:#FFCB6B;">Origin:https://juejin.cn</span></span>
<span class="line"><span style="color:#FFCB6B;">Pragma:no-cache</span></span></code></pre></div><p>请求头通知<strong>服务器</strong>有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息：</p><ul><li><strong>Host</strong>：表示主机名，虚拟主机</li><li><strong>Connection</strong>：HTTP/1.1 增加的，使用<code> keepalive</code>，即<strong>持久连接</strong>，一个连接可以发多个请求</li><li><strong>User-Agent</strong>：请求发出者，兼容性以及定制化需求</li></ul><h3 id="_4-3-请求体" tabindex="-1">4.3 请求体 <a class="header-anchor" href="#_4-3-请求体" aria-label="Permalink to &quot;4.3 请求体&quot;">​</a></h3><p>可以承载多个请求参数的数据，包含<strong>回车符、换行符和请求数据</strong>，并<strong>不是所有请求都具有请求数据。</strong></p><div class="language-php"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">tom</span><span style="color:#C792EA;">&amp;</span><span style="color:#A6ACCD;">password</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1234</span><span style="color:#C792EA;">&amp;</span><span style="color:#A6ACCD;">realName</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">tomson</span></span></code></pre></div><h2 id="_5、服务器处理请求并返回-http-报文" tabindex="-1">5、服务器处理请求并返回 HTTP 报文 <a class="header-anchor" href="#_5、服务器处理请求并返回-http-报文" aria-label="Permalink to &quot;5、服务器处理请求并返回 HTTP 报文&quot;">​</a></h2><h3 id="_5-1-http-响应报文" tabindex="-1">5.1 http 响应报文 <a class="header-anchor" href="#_5-1-http-响应报文" aria-label="Permalink to &quot;5.1 http 响应报文&quot;">​</a></h3><p>响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。</p><p><img src="`+e+'" alt="img"></p><p>(1) <strong>响应行</strong>包含：协议版本，状态码，状态码描述</p><p>状态码规则如下：</p><ul><li>1xx：指示信息--表示请求已接收，继续处理。</li><li>2xx：成功--表示请求已被成功接收、理解、接受。</li><li>3xx：重定向--要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误--请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误--服务器未能实现合法的请求。</li></ul><p>(2) <strong>响应头部</strong>包含响应报文的附加信息，由 名/值 对组成</p><img src="'+r+'" alt="image-20230612175512311" style="zoom:50%;"><p>(3) <strong>响应主体</strong>包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p><h2 id="_6、浏览器解析渲染页面" tabindex="-1">6、浏览器解析渲染页面 <a class="header-anchor" href="#_6、浏览器解析渲染页面" aria-label="Permalink to &quot;6、浏览器解析渲染页面&quot;">​</a></h2><h3 id="_1-根据-html-解析-dom-树" tabindex="-1">1.根据 HTML 解析 DOM 树 <a class="header-anchor" href="#_1-根据-html-解析-dom-树" aria-label="Permalink to &quot;1.根据 HTML 解析 DOM 树&quot;">​</a></h3><ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul><h3 id="_2-根据-css-解析生成-css-规则树" tabindex="-1">2.根据 CSS 解析生成 CSS 规则树 <a class="header-anchor" href="#_2-根据-css-解析生成-css-规则树" aria-label="Permalink to &quot;2.根据 CSS 解析生成 CSS 规则树&quot;">​</a></h3><ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul><h3 id="_3-结合-dom-树和-css-规则树-生成渲染树" tabindex="-1">3.结合 DOM 树和 CSS 规则树，生成渲染树 <a class="header-anchor" href="#_3-结合-dom-树和-css-规则树-生成渲染树" aria-label="Permalink to &quot;3.结合 DOM 树和 CSS 规则树，生成渲染树&quot;">​</a></h3><ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul><h3 id="_4-根据渲染树计算每一个节点的信息-布局" tabindex="-1">4.根据渲染树计算每一个节点的信息（布局） <a class="header-anchor" href="#_4-根据渲染树计算每一个节点的信息-布局" aria-label="Permalink to &quot;4.根据渲染树计算每一个节点的信息（布局）&quot;">​</a></h3><ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul><h3 id="_5-根据计算好的信息绘制页面" tabindex="-1">5.根据计算好的信息绘制页面 <a class="header-anchor" href="#_5-根据计算好的信息绘制页面" aria-label="Permalink to &quot;5.根据计算好的信息绘制页面&quot;">​</a></h3><ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li></ul><h2 id="_7、断开连接" tabindex="-1">7、断开连接 <a class="header-anchor" href="#_7、断开连接" aria-label="Permalink to &quot;7、断开连接&quot;">​</a></h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手</strong>。</p><p><img src="'+i+'" alt="img"></p><ul><li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态</strong>。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li><li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态</strong>。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态</strong>。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭</strong>。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ul>',57),h=[c];function d(g,C,m,u,_,D){return s(),l("div",null,h)}const A=a(p,[["render",d]]);export{P as __pageData,A as default};
