import{_ as o,o as t,c as e,O as a}from"./chunks/framework.23072b34.js";const c="/cocoLib/images/image-20230617113201820.png",q=JSON.parse('{"title":"重新安排行程(hard)","description":"","frontmatter":{},"headers":[],"relativePath":"算法/回溯/13 重新安排行程.md","filePath":"算法/回溯/13 重新安排行程.md","lastUpdated":null}'),i={name:"算法/回溯/13 重新安排行程.md"},s=a('<h1 id="重新安排行程-hard" tabindex="-1">重新安排行程(hard) <a class="header-anchor" href="#重新安排行程-hard" aria-label="Permalink to &quot;重新安排行程(hard)&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">Question</p><p>给你一份航线列表<code>tickets</code>，其中<code>tickets[i] = [fromi, toi]</code>表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从<code> JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从<code> JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><p>例如，行程<code> [&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;] </code>相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p></div><img src="'+c+'" alt="image-20230617113201820" style="zoom:67%;"><h1 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h1><p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p><p>实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p><p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路，在图论系列中我会再详细讲解深搜。</p><p><strong>这里就是先给大家拓展一下，原来回溯法还可以这么玩！</strong></p><p><strong>这道题目有几个难点：</strong></p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li><li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</li><li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li><li>搜索的过程中，如何遍历一个机场所对应的所有机场。</li></ol>',10),r=[s];function d(l,_,p,n,h,u){return t(),e("div",null,r)}const f=o(i,[["render",d]]);export{q as __pageData,f as default};
