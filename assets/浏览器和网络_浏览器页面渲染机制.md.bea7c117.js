import{_ as o,o as e,c as s,O as a}from"./chunks/framework.23072b34.js";const t="/cocoLib/images/webp-1686476278849-19.webp",l="/cocoLib/images/167f5262f5d0aaddtplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",r="/cocoLib/images/167f55aabacd4bactplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",c="/cocoLib/images/167f5652521fea2ftplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",n="/cocoLib/images/169debdd09eeccaatplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",p="/cocoLib/images/1640656e70765ac7tplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",i="/cocoLib/images/169e3dc0c4a438fdtplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",d="/cocoLib/images/167f068e4de6c7cetplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",g="/cocoLib/images/16809d8e6482b813tplv-t2oaga2asx-zoom-in-crop-mark3024000.webp",b=JSON.parse('{"title":"浏览器页面渲染机制","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器和网络/浏览器页面渲染机制.md","filePath":"浏览器和网络/浏览器页面渲染机制.md","lastUpdated":null}'),m={name:"浏览器和网络/浏览器页面渲染机制.md"},S=a('<h1 id="浏览器页面渲染机制" tabindex="-1">浏览器页面渲染机制 <a class="header-anchor" href="#浏览器页面渲染机制" aria-label="Permalink to &quot;浏览器页面渲染机制&quot;">​</a></h1><p><a href="https://juejin.cn/post/6844903815758479374" target="_blank" rel="noreferrer">你不知道的浏览器页面渲染机制 - 掘金 (juejin.cn)</a></p><p><a href="https://www.jianshu.com/p/1b493dce8d98" target="_blank" rel="noreferrer">「二」浏览器的渲染流程及组成【必会！】 - 简书 (jianshu.com)</a></p><ol><li><strong>页面加载过程是怎样的？</strong></li><li><strong>浏览器渲染过程分哪三部分？</strong></li><li><strong>Rendering Tree 渲染树等同于DOM树吗？</strong></li><li><strong>DOM是如何构建的？</strong></li><li><strong>CSSOM是如何构建的？</strong></li><li><strong>Rendering Tree是如何构建的？</strong></li><li><strong>浏览器如果渲染过程中遇到JS文件怎么处理？</strong></li><li><strong>async和defer的作用是什么？有什么区别?</strong></li><li><strong>为什么操作 DOM 慢?</strong></li><li><strong>回流和重绘是什么？有什么区别？</strong></li><li><strong>如何减少回流、重绘？</strong></li></ol><h2 id="_1-页面加载过程" tabindex="-1">1. 页面加载过程 <a class="header-anchor" href="#_1-页面加载过程" aria-label="Permalink to &quot;1. 页面加载过程&quot;">​</a></h2><ul><li>浏览器根据 DNS 服务器得到域名的 IP 地址</li><li>向这个 IP 的机器发送 HTTP 请求</li><li>服务器收到、处理并返回 HTTP 请求</li><li>浏览器得到返回内容</li></ul><h2 id="_2-浏览器渲染过程" tabindex="-1">2. 浏览器渲染过程 <a class="header-anchor" href="#_2-浏览器渲染过程" aria-label="Permalink to &quot;2. 浏览器渲染过程&quot;">​</a></h2><p><img src="'+t+'" alt="img"></p><ul><li><p>解析三个东西：</p><ul><li><code>HTML/SVG/XHTML</code> ➡ <code>DOM Tree</code></li><li><code>CSS</code> ➡ <code>CSS Rule Tree </code></li><li><code>Javascript</code>脚本</li></ul></li><li><p>解析完成后，浏览器引擎会通过<code>DOM Tree </code>和 <code>CSS Rule Tree</code> 来构造<code> Rendering Tree</code>。</p><ul><li><code>Rendering Tree</code> 渲染树并不等同于<code>DOM</code>树，渲染树只会包括需要显示的节点和这些节点的样式信息。</li><li><code>CSS </code>的 <code>Rule Tree</code>主要是为了完成匹配并把<code>CSS Rule</code>附加上<code>Rendering Tree</code>上的每个<code>Element</code>（也就是每个<code>Frame</code>）。</li><li>然后，计算每个<code>Frame </code>的位置，这又叫<code>layout</code>和<code>reflow</code>过程。</li></ul></li><li><p>最后通过调用操作系统<code>Native GUI</code>的API绘制。</p></li></ul><h2 id="_3-构建dom" tabindex="-1">3. 构建DOM <a class="header-anchor" href="#_3-构建dom" aria-label="Permalink to &quot;3. 构建DOM&quot;">​</a></h2><p><img src="'+l+'" alt="构建DOM的具体步骤"></p><ul><li>将字符串转换成<code>Token</code>，例如：<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>等。</li><li>生成节点对象（<code> Node</code>）并构建DOM：每个<code>Token</code>被生成后，会立刻消耗这个<code>Token</code>创建出节点对象。</li></ul><h2 id="_4-构建cssom" tabindex="-1">4. 构建CSSOM <a class="header-anchor" href="#_4-构建cssom" aria-label="Permalink to &quot;4. 构建CSSOM&quot;">​</a></h2><p><img src="'+r+'" alt="img"></p><p>构建<code>CSSOM</code>的过程与构建<code>DOM</code>的过程非常相似，当浏览器接收到一段<code>CSS</code>，浏览器首先要做的是识别出<code>Token</code>，然后构建节点并生成<code>CSSOM</code>。</p><p>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过<strong>继承</strong>获得。在这一过程中，浏览器得<strong>递归</strong> CSSOM 树，然后确定具体的元素到底是什么样式。</p><p><strong>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去</strong>。</p><h2 id="_5-构建渲染树" tabindex="-1">5. 构建渲染树 <a class="header-anchor" href="#_5-构建渲染树" aria-label="Permalink to &quot;5. 构建渲染树&quot;">​</a></h2><p>当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p><p><img src="'+c+'" alt="img"></p><ul><li><strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong>，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</li></ul><p><strong>浏览器如果渲染过程中遇到JS文件怎么处理</strong>？</p><p><img src="'+n+'" alt="img"></p><ul><li><p><strong>渲染过程中，如果遇到<code>&lt;script&gt;</code>就停止渲染，执行 JS 代码。</strong></p><p>因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。 JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。</p></li><li><p><strong>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建</strong></p><p>原本DOM和CSSOM的构建是互不影响，同时进行，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。</p><p>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，<strong>在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM</strong>。</p></li></ul><h2 id="_6-async和defer的作用是什么-有什么区别" tabindex="-1">6. async和defer的作用是什么？有什么区别? <a class="header-anchor" href="#_6-async和defer的作用是什么-有什么区别" aria-label="Permalink to &quot;6. async和defer的作用是什么？有什么区别?&quot;">​</a></h2><p><img src="'+p+'" alt="async和defer"></p><p><strong>1）情况1<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></strong></p><p>没有<code> defer</code> 或<code> async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><p><strong>2）情况2<code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></strong> (<strong>异步下载</strong>)</p><p><code>async</code> 属性表示<strong>异步执行</strong>引入的 <code>JavaScript</code>，与 <code>defer</code> 的区别在于，<strong>如果已经加载好，就会开始执行</strong>——无论此刻是 HTML 解析阶段还是 <code>DOMContentLoaded</code> 触发之后。需要注意的是，这种方式加载的<code> JavaScript</code> 依然会阻塞<code> load</code> 事件。换句话说，<code>async-script</code> 可能在 <code>DOMContentLoaded</code> 触发之前或之后执行，但一定在 load 触发之前执行。</p><p><strong>3）情况3 <code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></strong>(<strong>延迟执行</strong>)</p><p><code>defer</code> 属性表示<strong>延迟执行</strong>引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 <code>defer-script</code> 也加载完成之后（这两件事情的顺序无关），会执行所有由 <code>defer-script</code> 加载的 JavaScript 代码，然后触发 <code>DOMContentLoaded</code> 事件。</p><p>defer 与相比普通 script，有两点区别：</p><ul><li>**载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 **</li><li><strong>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。</strong></li></ul><h2 id="_7-为什么操作-dom-慢" tabindex="-1">7. 为什么操作 DOM 慢 <a class="header-anchor" href="#_7-为什么操作-dom-慢" aria-label="Permalink to &quot;7. 为什么操作 DOM 慢&quot;">​</a></h2><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p><p><img src="'+i+'" alt="img"></p><h2 id="_8-回流-reflow-和重绘-repaint" tabindex="-1">8. 回流（Reflow）和重绘（Repaint） <a class="header-anchor" href="#_8-回流-reflow-和重绘-repaint" aria-label="Permalink to &quot;8. 回流（Reflow）和重绘（Repaint）&quot;">​</a></h2><p><img src="'+d+'" alt="img"></p><ul><li><p><strong>重绘</strong></p><p>当我们对 DOM 的修改导致了样式的变化、却并未影响其<strong>几何属性</strong>（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。</p></li><li><p><strong>回流</strong></p><p>当我们对 DOM 的修改引发了 DOM <strong>几何尺寸</strong>的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（<strong>其他元素的几何属性和位置也会因此受到影响</strong>），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）</p></li><li><p><strong>二者联系</strong></p><p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p></li><li><p><strong>常见引起回流属性和方法</strong></p><ul><li>添加或者删除可见的DOM元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在input框中输入文字</li><li>浏览器窗口尺寸改变——resize事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li></ul></li><li><p><strong>常见引起重绘属性和方法</strong></p></li></ul><p><img src="'+g+`" alt="img"></p><ul><li><p><strong>如何减少回流、重绘</strong></p><ul><li><p>使用 <code>transform</code> 替代 <code>top</code></p></li><li><p>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起<strong>重绘</strong>，后者会引发<strong>回流（改变了布局）</strong></p></li><li><p>不要把节点的属性值放在一个循环里当成循环里的变量。</p></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">offsetTop</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ul><li><p>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个<code> table</code> 的重新布局</p></li><li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></p></li><li><p>CSS 选择符从右往左匹配查找，避免节点层级过多</p></li><li><p>将频繁重绘或者回流的节点设置为<strong>图层</strong>，<strong>图层能够阻止该节点的渲染行为影响别的节点</strong>。比如对于<code> video</code> 标签来说，浏览器会自动将该节点变为图层。</p></li></ul></li></ul>`,42),D=[S];function u(_,h,M,C,y,f){return e(),s("div",null,D)}const F=o(m,[["render",u]]);export{b as __pageData,F as default};
