import{_ as o,o as t,c as e,O as a}from"./chunks/framework.23072b34.js";const r="/cocoLib/images/166438086ada0b70tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",c="/cocoLib/images/16643a536f48ac12tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",s="/cocoLib/images/166445b31d2918b6tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",f=JSON.parse('{"title":"原型与原型链","description":"","frontmatter":{},"headers":[],"relativePath":"JS/JS面试题/10 原型与原型链.md","filePath":"JS/JS面试题/10 原型与原型链.md","lastUpdated":null}'),n={name:"JS/JS面试题/10 原型与原型链.md"},i=a('<h1 id="原型与原型链" tabindex="-1">原型与原型链 <a class="header-anchor" href="#原型与原型链" aria-label="Permalink to &quot;原型与原型链&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">参考</p><p><a href="https://juejin.cn/post/6844903687274364941" target="_blank" rel="noreferrer">原型与原型链详解 - 掘金 (juejin.cn)</a></p></div><ol><li>如何创建构造函数？</li><li>构造函数和普通函数有什么区别？</li><li>原型对象是什么？</li><li><code>__proto__</code>属性？？</li><li><code>constructor</code>属性？</li><li><code>prototype</code>属性？</li></ol><h2 id="_1、构造函数" tabindex="-1">1、构造函数 <a class="header-anchor" href="#_1、构造函数" aria-label="Permalink to &quot;1、构造函数&quot;">​</a></h2><ul><li>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。</li><li>另外就是<strong>调用方式</strong>的不同，普通函数是直接调用，<strong>而构造函数需要使用new关键字来调用</strong>。</li></ul><h2 id="_2、原型" tabindex="-1">2、原型 <a class="header-anchor" href="#_2、原型" aria-label="Permalink to &quot;2、原型&quot;">​</a></h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<code>prototype</code>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p><p>让我们用一张图表示<strong>构造函数</strong>和<strong>实例原型</strong>之间的关系：</p><p><img src="'+r+'" alt="img"></p><p><strong>原型对象</strong>就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p><p>为<strong>原型对象</strong>添加方法就相当于为类添加<strong>静态函数</strong>，每个实例直接通过<strong>类名</strong>访问，其目的是为了节省空间</p><h2 id="_3、原型链" tabindex="-1">3、原型链 <a class="header-anchor" href="#_3、原型链" aria-label="Permalink to &quot;3、原型链&quot;">​</a></h2><h3 id="_3-1-proto-和constructor" tabindex="-1">3.1 <code>__proto__</code>和<code>constructor</code> <a class="header-anchor" href="#_3-1-proto-和constructor" aria-label="Permalink to &quot;3.1 `__proto__`和`constructor`&quot;">​</a></h3><p><strong>每一个对象数据类型(普通的对象、实例、<code>prototype</code>......)也天生自带一个属性<code>__proto__</code>，属性值是当前实例所属类的原型(<code>prototype</code>)。原型对象中有一个属性<code>constructor</code>, 它指向函数对象。</strong></p><img src="'+c+'" alt="img" style="zoom:90%;"><h3 id="_3-2-何为原型链" tabindex="-1">3.2 何为原型链 <a class="header-anchor" href="#_3-2-何为原型链" aria-label="Permalink to &quot;3.2 何为原型链&quot;">​</a></h3><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去<strong>原型对象</strong>中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到<code>Object</code>对象的原型，<code>Object</code>对象的原型没有原型，如果在<code>Object</code>原型中依然没有找到，则返回<code>undefined</code>。</p><p><img src="'+s+'" alt="img"></p>',18),l=[i];function _(d,p,g,h,m,u){return t(),e("div",null,l)}const k=o(n,[["render",_]]);export{f as __pageData,k as default};
