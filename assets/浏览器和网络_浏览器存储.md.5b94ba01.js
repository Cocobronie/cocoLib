import{_ as o,o as e,c as a,O as t}from"./chunks/framework.23072b34.js";const r="/cocoLib/images/1699babec3c4fcc4tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",i="/cocoLib/images/1699f22b7029ca14tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",s="/cocoLib/images/1699bb1286c61eb4tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",c="/cocoLib/images/169b0739c22f84a7tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",n="/cocoLib/images/169a087c3a0738a9tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",d="/cocoLib/images/169a098c664137a0tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",l="/cocoLib/images/169d6872b64e96a9tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp",C=JSON.parse('{"title":"浏览器存储","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器和网络/浏览器存储.md","filePath":"浏览器和网络/浏览器存储.md","lastUpdated":null}'),g={name:"浏览器和网络/浏览器存储.md"},p=t('<h1 id="浏览器存储" tabindex="-1">浏览器存储 <a class="header-anchor" href="#浏览器存储" aria-label="Permalink to &quot;浏览器存储&quot;">​</a></h1><p><a href="https://juejin.cn/post/6844903812092674061" target="_blank" rel="noreferrer">深入了解浏览器存储--从cookie到WebStorage、IndexedDB - 掘金 (juejin.cn)</a></p><ol><li><code>Cookie</code>是什么?</li><li><code>Cookie</code>的作用?</li><li><code>Cookie</code>的原理及生成方式?</li><li><code>Cookie</code>的缺陷?</li><li><code>LocalStorage</code>特点?</li><li><code>LocalStorage</code>使用场景?</li><li><code>SessionStorage</code>特点?</li><li><code>SessionStorage</code>使用场景?</li><li><code>sessionStorage</code> 、<code>localStorage</code> 和 <code>cookie</code> 之间的区别?</li><li><code>IndexedDB </code>是什么？</li><li><code>IndexedDB</code>的特点?</li><li><code>WebStorage</code>、<code>cookie</code> 和 <code>IndexedDB</code>之间的区别</li></ol><h2 id="_1、cookie" tabindex="-1">1、Cookie <a class="header-anchor" href="#_1、cookie" aria-label="Permalink to &quot;1、Cookie&quot;">​</a></h2><h3 id="是什么" tabindex="-1"><strong>是什么</strong> <a class="header-anchor" href="#是什么" aria-label="Permalink to &quot;**是什么**&quot;">​</a></h3><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。</p><p><img src="'+r+'" alt="img"></p><p><strong>Cookie 以键值对的形式存在</strong></p><p>我们可以把<code>Cookie</code> 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 <code>Cookie</code> 的时候，便可以获取到客户端的状态。</p><h3 id="能干什么" tabindex="-1"><strong>能干什么</strong> <a class="header-anchor" href="#能干什么" aria-label="Permalink to &quot;**能干什么**&quot;">​</a></h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”</strong>。 因为<strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。</p><h3 id="cookie的原理" tabindex="-1">Cookie的原理 <a class="header-anchor" href="#cookie的原理" aria-label="Permalink to &quot;Cookie的原理&quot;">​</a></h3><p><img src="'+i+'" alt="img"></p><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p><h3 id="生成方式" tabindex="-1"><strong>生成方式</strong> <a class="header-anchor" href="#生成方式" aria-label="Permalink to &quot;**生成方式**&quot;">​</a></h3><ul><li>生成方式一：<code>http response header</code>中的<code>set-cookie</code></li><li>生成方式二：js中可以通过<code>document.cookie</code>可以读写<code>cookie</code>，以键值对的形式展示</li></ul><p><img src="'+s+'" alt="img"></p><p><strong>Domain 标识指定了哪些域名可以接受Cookie</strong>。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p><h3 id="cookie的缺陷" tabindex="-1">Cookie的缺陷 <a class="header-anchor" href="#cookie的缺陷" aria-label="Permalink to &quot;Cookie的缺陷&quot;">​</a></h3><ul><li><strong>Cookie 不够大</strong></li></ul><p>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。</p><p>这里需注意：各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</p><ul><li><strong>过多的 Cookie 会带来巨大的性能浪费</strong></li></ul><p>Cookie 是紧跟域名的。<strong>同一个域名下的所有请求，都会携带 Cookie</strong>。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p><p>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过<strong>cdn（存储静态文件的）的域名</strong>和<strong>主站的域名</strong>分开来解决。</p><ul><li>由于在HTTP请求中的Cookie是<strong>明文传递</strong>的，所以<strong>安全性成问题</strong>，除非用HTTPS。</li></ul><p><img src="'+c+'" alt="img"></p><h2 id="_2、localstorage" tabindex="-1">2、LocalStorage <a class="header-anchor" href="#_2、localstorage" aria-label="Permalink to &quot;2、LocalStorage&quot;">​</a></h2><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li><li>大小为5M左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好</li></ul><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p><code>LocalStorage</code>在存储方面没有什么特别的限制，理论上 <code>Cookie</code> 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 <code>LocalStorage</code> 来做。</p><p>这里给大家举个例子，考虑到<code> LocalStorage</code> 的特点之一是<strong>持久</strong>，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p><p><img src="'+n+'" alt="img"></p><h2 id="_3、sessionstorage" tabindex="-1">3、sessionStorage <a class="header-anchor" href="#_3、sessionstorage" aria-label="Permalink to &quot;3、sessionStorage&quot;">​</a></h2><h3 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>会话级别的浏览器存储</li><li>大小为5M左右</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好</li></ul><p><strong>会话：</strong></p><p><code>sessionStorage</code>保存的数据用于浏览器的一次会话，当<strong>会话</strong>结束（通常是该窗口关闭），数据被清空；<code>sessionStorage </code>特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 <code>sessionStorage</code> 内容便无法共享</strong></p><h3 id="使用场景-1" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-1" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p><code>sessionStorage</code> 更适合用来存储<strong>生命周期</strong>和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 <code>sessionStorage</code>就主要是存储你本次会话的<strong>浏览足迹</strong>：</p><p><img src="'+d+'" alt="img"></p><p><code>lasturl </code>对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 <code>sessionStorage</code> 来处理再合适不过。</p><h2 id="_4、sessionstorage-、localstorage-之间的区别" tabindex="-1">4、sessionStorage 、localStorage 之间的区别 <a class="header-anchor" href="#_4、sessionstorage-、localstorage-之间的区别" aria-label="Permalink to &quot;4、sessionStorage 、localStorage 之间的区别&quot;">​</a></h2><ul><li>**共同点：**都是保存在浏览器端，且都遵循同源策略。</li><li>**不同点：**在于生命周期与作用域的不同</li></ul><h3 id="作用域" tabindex="-1"><strong>作用域</strong> <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;**作用域**&quot;">​</a></h3><p><code>localStorage</code>只要在相同的<strong>协议</strong>、相同的<strong>主机名</strong>、相同的<strong>端口</strong>下，就能读取/修改到同一份<code>localStorage</code>数据。<code>sessionStorage</code>比<code>localStorage</code>更严苛一点，除了<strong>协议</strong>、<strong>主机名</strong>、<strong>端口</strong>外，还要求在同一<strong>窗口</strong>（也就是浏览器的标签页）下</p><h3 id="生命周期" tabindex="-1"><strong>生命周期</strong> <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;**生命周期**&quot;">​</a></h3><p><code>localStorage</code> 是<strong>持久化</strong>的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而<code>sessionStorage</code>是<strong>临时性</strong>的本地存储，它是会话级别的存储，当会话结束（页面被关闭)时，存储内容也随之被释放。</p><p><code>Web Storage </code>是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——<strong>它只能存储字符串</strong>，要想得到对象，我们还需要先对字符串进行一轮解析。</p><p>说到底，<code>Web Storage</code> 是对 <code>Cookie</code> 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，<code>Web Storage</code> 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——<code>IndexedDB</code>！</p><h2 id="_5、indexeddb" tabindex="-1">5、IndexedDB <a class="header-anchor" href="#_5、indexeddb" aria-label="Permalink to &quot;5、IndexedDB&quot;">​</a></h2><h3 id="是什么-1" tabindex="-1">是什么 <a class="header-anchor" href="#是什么-1" aria-label="Permalink to &quot;是什么&quot;">​</a></h3><p><code>IndexedDB</code> 是一种<strong>低级API</strong>，<strong>用于客户端存储大量结构化数据(包括文件和blobs)</strong>。该API使用<strong>索引</strong>来实现对该数据的高性能搜索。<code>IndexedDB</code> 是一个<strong>运行在浏览器上</strong>的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是<strong>没有存储上限</strong>的（一般来说不会小于 250M）。它不仅可以存储<strong>字符串</strong>，还可以存储<strong>二进制数据</strong>。</p><h3 id="indexeddb的特点" tabindex="-1">IndexedDB的特点 <a class="header-anchor" href="#indexeddb的特点" aria-label="Permalink to &quot;IndexedDB的特点&quot;">​</a></h3><ul><li><strong>键值对储存</strong></li></ul><p><code>IndexedDB </code>内部采用**对象仓库（object store）**存放数据。<strong>所有类型</strong>的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以&quot;键值对&quot;的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p><ul><li><strong>异步</strong></li></ul><p><code>IndexedDB</code> 操作时不会锁死浏览器，用户依然可以进行其他操作，这与<code> LocalStorage</code> 形成对比，后者的操作是同步的。<strong>异步设计</strong>是为了防止大量数据的读写，拖慢网页的表现。</p><ul><li><strong>支持事务</strong></li></ul><p><code>IndexedDB </code>支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，<strong>不存在只改写一部分数据的情况</strong>。</p><ul><li><strong>同源限制</strong></li></ul><p><code>IndexedDB</code> 受到同源限制，每一个数据库对应创建它的<strong>域名</strong>。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p><ul><li><strong>储存空间大</strong></li></ul><p><code>IndexedDB</code> 的储存空间比<code>LocalStorage</code>大得多，一般来说不少于 250MB，甚至没有上限。</p><ul><li><strong>支持二进制储存</strong></li></ul><p><code>IndexedDB</code> 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p><h2 id="_6、webstorage、cookie-和-indexeddb之间的区别" tabindex="-1">6、WebStorage、cookie 和 IndexedDB之间的区别 <a class="header-anchor" href="#_6、webstorage、cookie-和-indexeddb之间的区别" aria-label="Permalink to &quot;6、WebStorage、cookie 和 IndexedDB之间的区别&quot;">​</a></h2><p><img src="'+l+'" alt="img"></p>',69),h=[p];function k(b,u,m,_,x,S){return e(),a("div",null,h)}const f=o(g,[["render",k]]);export{C as __pageData,f as default};
