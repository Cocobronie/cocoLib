import{_ as a,o as t,c as l,O as e}from"./chunks/framework.23072b34.js";const b=JSON.parse('{"title":"作用域和作用域链","description":"","frontmatter":{},"headers":[],"relativePath":"JS/JS面试题/05 作用域和作用域链.md","filePath":"JS/JS面试题/05 作用域和作用域链.md","lastUpdated":null}'),i={name:"JS/JS面试题/05 作用域和作用域链.md"},r=e('<h1 id="作用域和作用域链" tabindex="-1">作用域和作用域链 <a class="header-anchor" href="#作用域和作用域链" aria-label="Permalink to &quot;作用域和作用域链&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">参考</p><p><a href="https://juejin.cn/post/6844903797135769614" target="_blank" rel="noreferrer">深入理解JavaScript作用域和作用域链 - 掘金 (juejin.cn)</a></p></div><ol><li>什么是作用域？</li><li>什么是全局作用域？</li><li>什么是函数作用域？</li><li>什么是块级作用域？</li><li>什么是自由变量？</li><li>什么是作用域链？</li><li>作用域与执行上下文的区别？</li></ol><h2 id="_1、作用域-scope" tabindex="-1">1、作用域(Scope) <a class="header-anchor" href="#_1、作用域-scope" aria-label="Permalink to &quot;1、作用域(Scope)&quot;">​</a></h2><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。</p><p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现。</p><h3 id="_1-1-全局作用域" tabindex="-1">1.1 全局作用域 <a class="header-anchor" href="#_1-1-全局作用域" aria-label="Permalink to &quot;1.1 全局作用域&quot;">​</a></h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p><ul><li><strong>最外层函数</strong>和在<strong>最外层函数外面定义的变量</strong>拥有全局作用域</li><li>所有<strong>未定义直接赋值</strong>的变量</li><li>所有<strong>window对象的属性</strong>拥有全局作用域</li></ul><h3 id="_1-2-函数作用域" tabindex="-1">1.2 函数作用域 <a class="header-anchor" href="#_1-2-函数作用域" aria-label="Permalink to &quot;1.2 函数作用域&quot;">​</a></h3><p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。</p><h3 id="_1-3-块级作用域" tabindex="-1">1.3 块级作用域 <a class="header-anchor" href="#_1-3-块级作用域" aria-label="Permalink to &quot;1.3 块级作用域&quot;">​</a></h3><p>块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p><strong>块级作用域有以下几个特点：</strong></p><ul><li>声明变量不会提升到代码块顶部</li><li>禁止重复声明</li><li>循环中的绑定块作用域的妙用</li></ul><h2 id="_2、作用域链" tabindex="-1">2、作用域链 <a class="header-anchor" href="#_2、作用域链" aria-label="Permalink to &quot;2、作用域链&quot;">​</a></h2><h3 id="_2-1-什么是自由变量" tabindex="-1">2.1 什么是自由变量 <a class="header-anchor" href="#_2-1-什么是自由变量" aria-label="Permalink to &quot;2.1 什么是自由变量&quot;">​</a></h3><p>当前作用域没有定义的变量，这成为<strong>自由变量</strong> 。自由变量的值如何得到 —— 向父级作用域寻找。</p><h3 id="_2-2-什么是作用域链" tabindex="-1">2.2 什么是作用域链 <a class="header-anchor" href="#_2-2-什么是作用域链" aria-label="Permalink to &quot;2.2 什么是作用域链&quot;">​</a></h3><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是<strong>作用域链</strong> 。</p><h2 id="_3、作用域与执行上下文" tabindex="-1">3、作用域与执行上下文 <a class="header-anchor" href="#_3、作用域与执行上下文" aria-label="Permalink to &quot;3、作用域与执行上下文&quot;">​</a></h2><p>JavaScript属于<strong>解释型</strong>语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p><h3 id="_3-1-解释阶段" tabindex="-1">3.1 解释阶段： <a class="header-anchor" href="#_3-1-解释阶段" aria-label="Permalink to &quot;3.1 解释阶段：&quot;">​</a></h3><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><h3 id="_3-2-执行阶段" tabindex="-1">3.2 执行阶段： <a class="header-anchor" href="#_3-2-执行阶段" aria-label="Permalink to &quot;3.2 执行阶段：&quot;">​</a></h3><ul><li>创建执行上下文</li><li>执行函数代码</li><li>垃圾回收</li></ul><p>JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是<code>this</code>的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p><p>作用域和执行上下文之间最大的区别是： <strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong>。</p>',30),o=[r];function n(s,h,c,_,d,p){return t(),l("div",null,o)}const g=a(i,[["render",n]]);export{b as __pageData,g as default};
